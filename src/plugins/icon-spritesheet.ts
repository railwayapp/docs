import { mkdir, readdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";

const INPUT_DIR = "src/assets/icons";
const OUTPUT_DIR = "public/icons";
const TYPES_OUTPUT_FILE = "src/assets/icons/types.ts";
const FILE_NAME = "sprite.svg";
const CWD = process.cwd();

const colors = {
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  blueBright: (s: string) => `\x1b[94m${s}\x1b[0m`,
};

const transformIconName = (fileName: string): string =>
  fileName
    .split("-")
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");

const generateIcons = async () => {
  const inputDirRelative = path.relative(CWD, INPUT_DIR);
  const outputDirRelative = path.relative(CWD, OUTPUT_DIR);

  const allFiles = await readdir(INPUT_DIR);
  const files = allFiles.filter(file => file.endsWith(".svg"));

  if (files.length === 0) {
    console.log(`‚ö†Ô∏è  No SVG files found in ${colors.red(inputDirRelative)}`);
    return;
  }

  await mkdir(outputDirRelative, { recursive: true });
  await generateSvgSprite(files, outputDirRelative);
  await generateTypes(
    files.map(file => transformIconName(file.replace(/\.svg$/, ""))),
  );
};

const PRESERVED_ATTRS = [
  "viewBox",
  "preserveAspectRatio",
  "fill",
  "fill-rule",
  "fill-opacity",
  "stroke",
  "stroke-width",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-miterlimit",
  "stroke-opacity",
  "clip-rule",
  "clip-path",
  "mask",
  "opacity",
  "color",
  "vector-effect",
  "shape-rendering",
  "transform",
  "transform-origin",
];

function parseSvgToSymbol(input: string, id: string): string | null {
  const svgOpenMatch = input.match(/<svg([^>]*)>/i);
  if (!svgOpenMatch) return null;

  const attrsStr = svgOpenMatch[1];
  const preservedAttrs = PRESERVED_ATTRS.map(attr => {
    const match = attrsStr.match(
      new RegExp(`${attr}\\s*=\\s*["']([^"']*)["']`, "i"),
    );
    if (!match) return "";
    if (attr === "fill" && match[1] === "none") return "";
    return ` ${attr}="${match[1]}"`;
  }).join("");

  const innerMatch = input.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
  if (!innerMatch) return null;

  return `<symbol id="${id}"${preservedAttrs}>${innerMatch[1]}</symbol>`;
}

async function generateSvgSprite(files: string[], outputDirRelative: string) {
  const failures: string[] = [];

  const symbols = await Promise.all(
    files.map(async file => {
      const iconName = transformIconName(file.replace(/\.svg$/, ""));
      const input = await readFile(path.join(INPUT_DIR, file), "utf-8");
      const symbol = parseSvgToSymbol(input, iconName);

      if (!symbol) {
        failures.push(file);
        return null;
      }
      return symbol.trim();
    }),
  );

  if (failures.length > 0) {
    console.log(
      `${colors.yellow("‚ö†Ô∏è")} Failed to parse: ${failures.join(", ")}`,
    );
  }

  const output = [
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">',
    "<defs>",
    ...symbols.filter(Boolean),
    "</defs>",
    "</svg>",
  ].join("\n");

  return writeIfChanged(
    path.join(OUTPUT_DIR, FILE_NAME),
    output,
    `üñºÔ∏è  Generated SVG spritesheet in ${colors.green(outputDirRelative)}`,
  );
}

async function generateTypes(names: string[]) {
  const output = [
    "// This file is generated by icon spritesheet generator",
    "",
    "export const iconNames = [",
    ...names.map(name => `  "${name}",`),
    "] as const",
    "",
    "export type IconName = typeof iconNames[number]",
    "",
  ].join("\n");

  const typesOutputDir = path.dirname(TYPES_OUTPUT_FILE);
  const typesOutputDirRelative = path.relative(CWD, typesOutputDir);

  await mkdir(typesOutputDirRelative, { recursive: true });

  return writeIfChanged(
    TYPES_OUTPUT_FILE,
    output,
    `${colors.blueBright("TS")} Generated icon types in ${colors.green(
      TYPES_OUTPUT_FILE,
    )}`,
  );
}

async function writeIfChanged(
  filepath: string,
  newContent: string,
  message: string,
) {
  try {
    const currentContent = await readFile(filepath, "utf-8");
    if (currentContent !== newContent) {
      await writeFile(filepath, newContent, "utf-8");
      console.log(message);
    }
  } catch {
    await writeFile(filepath, newContent, "utf-8");
    console.log(message);
  }
}

// Run the generator
generateIcons().catch(error => {
  console.error("Failed to generate icons:", error);
  process.exit(1);
});
